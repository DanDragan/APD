import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Vector;

public class Reduce extends PartialSolution {

	String file, selectedFile;
	private Vector<HashMap<String, Integer>> allWords;
	private HashMap<String, Integer> totalWords;
	private HashMap<String, Double> frequencies;
	int numWords, sim;
	boolean canCompute;

	public Reduce(Vector<HashMap<String, Integer>> allWords, String file,
			String selectedFile) {
		this.allWords = allWords;
		this.file = file;
		this.selectedFile = selectedFile;
		totalWords = new HashMap<String, Integer>();
		frequencies = new HashMap<String, Double>();
		numWords = 0;
		sim = 0;
	}

	public void combinePartialVectors() {
		for (HashMap<String, Integer> hmap : allWords) {
			Iterator<Entry<String, Integer>> entries = hmap.entrySet()
					.iterator();
			while (entries.hasNext()) {
				Entry<String, Integer> entry = entries.next();
				int freq = entry.getValue();
				numWords += freq;
				if (totalWords.containsKey(entry.getKey())) {
					freq += totalWords.get(entry.getKey());
				}
				totalWords.put(entry.getKey(), freq);
			}
		}
		Iterator<Entry<String, Integer>> entries = totalWords.entrySet()
				.iterator();
		while (entries.hasNext()) {
			double frequency = 0.0;
			Entry<String, Integer> entry = entries.next();
			frequency = (entry.getValue() / numWords) * 100;
			if(frequency > 0.00)
				System.out.println(entry.getKey());
			String value = entry.getKey();
			frequencies.put(value, frequency);
			Main.mapFreqToFile(file, frequencies);
		}
		//System.out.println(frequencies);
	}

	public void determineSymmetry() {
		canCompute = false;
		//System.out.println(Main.fmap.get(file));
		if (!file.equals(selectedFile)) {
			if (Main.fmap.get(selectedFile) != null
					&& Main.fmap.get(file) != null) {
				HashMap<String, Double> smap = Main.fmap.get(selectedFile);
				HashMap<String, Double> fmap = Main.fmap.get(file);

				Iterator<Entry<String, Double>> entries1 = smap.entrySet()
						.iterator();
				while (entries1.hasNext()) {
					Entry<String, Double> entry1 = entries1.next();
					Iterator<Entry<String, Double>> entries2 = fmap.entrySet()
							.iterator();
					while (entries2.hasNext()) {
						Entry<String, Double> entry2 = entries2.next();
						if (entry1.getKey().equals(entry2.getKey())) {
							sim += entry1.getValue() * entry2.getValue();
						}
					}
				}
				canCompute = true;
				//System.out.println(sim);
			}
		}

	}

	@Override
	public void go() {
		combinePartialVectors();
		determineSymmetry();
	}

	HashMap<String, Double> getFrequencies() {
		return frequencies;
	}

	int getSim() {
		return sim;
	}

	String getFile() {
		return file;
	}
	
	boolean canCompute() {
		return canCompute;
	}

	HashMap<String, Integer> getFileMap() {
		return totalWords;
	}
}